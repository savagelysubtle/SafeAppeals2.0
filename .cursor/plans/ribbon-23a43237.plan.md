<!-- 23a43237-3e96-4ee0-9dd5-303d9164720e 57a5e2ea-68c3-44b5-bbda-9a8f07eb75f3 -->
# Safe Appeals Navigator - Complete RAG Implementation

## Executive Summary

Build Safe Appeals Navigator as a **hybrid built-in system** with:

- Core RAG services in `src/vs/workbench/contrib/void` (built-in)
- Extension UI in `extensions/safe-appeals-nav` (sidebar viewlet + document viewer)
- Shared storage using existing SQLite database + Chroma vector store
- Tool integration with Void chat agent
- Multi-format document viewer (PDF, DOCX, TXT, MD)

## Architecture Overview

### Storage Architecture

**Primary Database**: Extend existing `state.vscdb` (SQLite) at `globalStorageHome`

- Add RAG tables alongside `ItemTable` in `src/vs/base/parts/storage/node/storage.ts`
- Store in: `IEnvironmentService.userRoamingDataHome/.appealsnavigator/databases/`

**Vector Database**: Chroma collections at `globalStorageHome/chroma/`

- Collections: `policy_manual` and `workspace_docs`
- OpenAI embeddings: text-embedding-3-small (configurable to 3-large)
- Future: sqlite-vec adapter option

### Service Architecture

**Electron-Main Services** (heavy I/O + native modules):

- `RAGMainService` - orchestrates indexing/search
- `RAGIndexService` - document chunking, SQLite writes
- `RAGFileService` - PDF/DOCX/TXT/MD extraction
- `RAGVectorAdapter` - Chroma abstraction

**Browser Services** (UI integration):

- `RAGContextService` - context pack assembly for LLM
- Channel communication to main process

**Extension** (UI layer):

- Tree view provider for policy documents
- Custom editor for multi-format viewing
- Commands for upload/search/refresh

## Database Schema

### Extend SQLiteStorageDatabase

**Location**: `src/vs/base/parts/storage/node/storage.ts`

Add to `doConnect()` method after existing table creation:

```sql
CREATE TABLE IF NOT EXISTS rag_documents (
  id TEXT PRIMARY KEY,
  filename TEXT NOT NULL,
  filepath TEXT NOT NULL,
  filetype TEXT NOT NULL,
  filesize INTEGER NOT NULL,
  uploadedAt DATETIME DEFAULT CURRENT_TIMESTAMP,
  lastIndexed DATETIME DEFAULT CURRENT_TIMESTAMP,
  checksum TEXT,
  metadata TEXT
);

CREATE TABLE IF NOT EXISTS rag_chunks (
  chunkId TEXT PRIMARY KEY,
  docId TEXT NOT NULL,
  text TEXT NOT NULL,
  chunkIndex INTEGER NOT NULL,
  tokens INTEGER,
  FOREIGN KEY(docId) REFERENCES rag_documents(id) ON DELETE CASCADE
);

CREATE TABLE IF NOT EXISTS rag_policy_sections (
  sectionId TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  level INTEGER NOT NULL,
  parentId TEXT,
  docId TEXT NOT NULL,
  pageNumber INTEGER,
  chunkIds TEXT,
  FOREIGN KEY(docId) REFERENCES rag_documents(id) ON DELETE CASCADE,
  FOREIGN KEY(parentId) REFERENCES rag_policy_sections(sectionId)
);

CREATE TABLE IF NOT EXISTS rag_search_history (
  id TEXT PRIMARY KEY,
  query TEXT NOT NULL,
  collection TEXT NOT NULL,
  timestamp DATETIME DEFAULT CURRENT_TIMESTAMP,
  resultCount INTEGER,
  responseTime INTEGER
);

CREATE INDEX IF NOT EXISTS idx_rag_documents_filetype ON rag_documents(filetype);
CREATE INDEX IF NOT EXISTS idx_rag_documents_uploaded ON rag_documents(uploadedAt);
CREATE INDEX IF NOT EXISTS idx_rag_chunks_docid ON rag_chunks(docId);
CREATE INDEX IF NOT EXISTS idx_rag_policy_sections_docid ON rag_policy_sections(docId);
```

## Implementation - Phase 1: Core Services

### Step 1: Type Definitions and Settings

**File**: `src/vs/workbench/contrib/void/common/ragServiceTypes.ts` (already exists, enhance)

Add to existing types:

```typescript
export interface ContextPack {
  answerContext: string;
  attributions: Array<{
    docId: string;
    chunkId: string;
    filename: string;
    rangeHint: string;
    score: number;
  }>;
  totalResults: number;
  responseTime: number;
}

export interface RAGIndexParams {
  uri: URI;
  isPolicyManual: boolean;
  workspaceId?: string;
}

export interface RAGSearchParams {
  query: string;
  scope: 'policy_manual' | 'workspace_docs' | 'both';
  limit: number;
  workspaceId?: string;
}
```

**File**: `src/vs/workbench/contrib/void/common/voidSettingsTypes.ts` (modify)

Add to `IVoidSettingsService`:

```typescript
ragEnabled: boolean; // default: true
ragChunkSize: number; // default: 500
ragChunkOverlap: number; // default: 50
ragSearchLimit: number; // default: 5
ragStorageScope: RAGStorageScope; // 'global' | 'workspace' | 'both'
ragVectorBackend: RAGVectorBackend; // 'chroma-http' | 'sqlite-vec'
ragOpenAIModel: RAGOpenAIModel; // 'text-embedding-3-small' | 'text-embedding-3-large'
ragChromaUrl?: string; // default: 'http://localhost:8000'
```

### Step 2: Path Resolution Service

**File**: `src/vs/workbench/contrib/void/common/ragPathService.ts` (new)

```typescript
import { IEnvironmentService } from '../../../platform/environment/common/environment.js';
import { URI } from '../../../base/common/uri.js';
import { join } from '../../../base/common/path.js';

export class RAGPathService {
  constructor(@IEnvironmentService private envService: IEnvironmentService) {}
  
  getGlobalStorageDir(): URI {
    return URI.joinPath(this.envService.userRoamingDataHome, '.appealsnavigator', 'databases');
  }
  
  getGlobalChromaDir(): URI {
    return URI.joinPath(this.getGlobalStorageDir(), 'chroma');
  }
  
  getGlobalSqlitePath(): URI {
    // Use existing state.vscdb
    return URI.joinPath(this.envService.globalStorageHome, 'state.vscdb');
  }
  
  getWorkspaceChromaDir(workspaceId: string): URI {
    return URI.joinPath(this.getGlobalStorageDir(), 'workspaces', workspaceId, 'chroma');
  }
  
  async ensureDirectories(): Promise<void> {
    // Create necessary directories
  }
}
```

### Step 3: Vector Adapter Abstraction

**File**: `src/vs/workbench/contrib/void/electron-main/ragVectorAdapter.ts` (new)

```typescript
export interface IRAGVectorAdapter {
  ensureCollections(scope: 'policy_manual' | 'workspace_docs'): Promise<void>;
  add(collectionName: string, chunks: ChunkData[]): Promise<void>;
  query(collectionName: string, query: string, n: number): Promise<SearchResult[]>;
  close(): Promise<void>;
}

interface ChunkData {
  id: string;
  document: string;
  metadata: any;
}

export class ChromaHttpAdapter implements IRAGVectorAdapter {
  private client: ChromaClient;
  private embeddingFunction: OpenAIEmbeddingFunction;
  
  constructor(chromaUrl: string, openaiApiKey: string, model: string) {
    this.client = new ChromaClient({ path: chromaUrl });
    this.embeddingFunction = new OpenAIEmbeddingFunction({
      openai_api_key: openaiApiKey,
      openai_model: model
    });
  }
  
  async ensureCollections(scope: string): Promise<void> {
    try {
      await this.client.getCollection({
        name: scope,
        embeddingFunction: this.embeddingFunction
      });
    } catch {
      await this.client.createCollection({
        name: scope,
        embeddingFunction: this.embeddingFunction
      });
    }
  }
  
  // Implement add(), query(), close()...
}

// Stub for future
export class SqliteVecAdapter implements IRAGVectorAdapter {
  // Phase 2 implementation
}
```

### Step 4: File Extraction Service

**File**: `src/vs/workbench/contrib/void/electron-main/ragFileService.ts` (new)

```typescript
import * as pdfjsLib from 'pdfjs-dist';
import * as mammoth from 'mammoth';
import { ExtractedContent } from '../common/ragServiceTypes.js';

export class RAGFileService {
  constructor() {
    // Configure PDF.js worker
    pdfjsLib.GlobalWorkerOptions.workerSrc = require.resolve('pdfjs-dist/build/pdf.worker.js');
  }
  
  async extractText(uri: URI): Promise<ExtractedContent> {
    const ext = extname(uri.fsPath).toLowerCase();
    
    switch (ext) {
      case '.pdf':
        return this.extractFromPdf(uri);
      case '.docx':
        return this.extractFromDocx(uri);
      case '.txt':
      case '.md':
        return this.extractFromText(uri);
      default:
        throw new Error(`Unsupported file type: ${ext}`);
    }
  }
  
  private async extractFromPdf(uri: URI): Promise<ExtractedContent> {
    const buffer = await readFile(uri.fsPath);
    const pdf = await pdfjsLib.getDocument({ data: buffer }).promise;
    
    let fullText = '';
    for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
      const page = await pdf.getPage(pageNum);
      const textContent = await page.getTextContent();
      const pageText = textContent.items
        .filter((item: any) => 'str' in item)
        .map((item: any) => item.str)
        .join(' ');
      fullText += pageText + '\n';
    }
    
    return {
      text: fullText.trim(),
      metadata: {
        pageCount: pdf.numPages,
        wordCount: this.countWords(fullText),
        language: this.detectLanguage(fullText)
      }
    };
  }
  
  private async extractFromDocx(uri: URI): Promise<ExtractedContent> {
    const buffer = await readFile(uri.fsPath);
    const result = await mammoth.extractRawText({ buffer });
    
    return {
      text: result.value,
      metadata: {
        wordCount: this.countWords(result.value),
        language: this.detectLanguage(result.value)
      }
    };
  }
  
  // Helper methods...
}
```

### Step 5: Index Service

**File**: `src/vs/workbench/contrib/void/electron-main/ragIndexService.ts` (new)

```typescript
import Database from '@vscode/sqlite3';
import * as crypto from 'crypto';

export class RAGIndexService {
  constructor(
    private sqlite: Database,
    private vectorAdapter: IRAGVectorAdapter,
    private fileService: RAGFileService
  ) {}
  
  async indexDocument(uri: URI, isPolicyManual: boolean): Promise<string> {
    const startTime = Date.now();
    
    // Generate checksum
    const fileBuffer = await readFile(uri.fsPath);
    const checksum = crypto.createHash('sha256').update(fileBuffer).digest('hex');
    const docId = `${basename(uri.fsPath)}-${checksum.substring(0, 8)}`;
    
    // Check if already indexed
    const existingDoc = this.sqlite.prepare(
      'SELECT id FROM rag_documents WHERE checksum = ?'
    ).get(checksum);
    
    if (existingDoc) {
      return existingDoc.id as string;
    }
    
    // Extract text
    const { text, metadata } = await this.fileService.extractText(uri);
    
    if (!text || text.trim().length === 0) {
      throw new Error('No text content extracted');
    }
    
    // Store document metadata
    const stat = await stat(uri.fsPath);
    this.sqlite.prepare(`
      INSERT INTO rag_documents (id, filename, filepath, filetype, filesize, checksum, metadata)
      VALUES (?, ?, ?, ?, ?, ?, ?)
    `).run(
      docId,
      basename(uri.fsPath),
      uri.fsPath,
      extname(uri.fsPath).slice(1).toLowerCase(),
      stat.size,
      checksum,
      JSON.stringify(metadata)
    );
    
    // Chunk text
    const chunks = await this.chunkText(text, 500, 50);
    
    // Store chunks in SQLite + vector store
    const collectionName = isPolicyManual ? 'policy_manual' : 'workspace_docs';
    const chunkRecords: ChunkData[] = [];
    
    for (let i = 0; i < chunks.length; i++) {
      const chunkId = `${docId}-chunk-${i}`;
      const tokens = this.estimateTokens(chunks[i]);
      
      this.sqlite.prepare(`
        INSERT INTO rag_chunks (chunkId, docId, text, chunkIndex, tokens)
        VALUES (?, ?, ?, ?, ?)
      `).run(chunkId, docId, chunks[i], i, tokens);
      
      chunkRecords.push({
        id: chunkId,
        document: chunks[i],
        metadata: {
          docId,
          filename: basename(uri.fsPath),
          filetype: extname(uri.fsPath).slice(1),
          chunkIndex: i,
          isPolicyManual
        }
      });
    }
    
    await this.vectorAdapter.add(collectionName, chunkRecords);
    
    return docId;
  }
  
  private async chunkText(text: string, chunkSize: number, overlap: number): Promise<string[]> {
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 0);
    const chunks: string[] = [];
    let currentChunk = '';
    
    for (const sentence of sentences) {
      const trimmed = sentence.trim();
      
      if ((currentChunk + ' ' + trimmed).length > chunkSize && currentChunk.length > 0) {
        chunks.push(currentChunk.trim());
        
        // Create overlap
        const words = currentChunk.split(' ');
        const overlapWords = words.slice(-Math.min(overlap, words.length));
        currentChunk = overlapWords.join(' ') + ' ' + trimmed;
      } else {
        currentChunk += (currentChunk ? ' ' : '') + trimmed;
      }
    }
    
    if (currentChunk.trim().length > 0) {
      chunks.push(currentChunk.trim());
    }
    
    return chunks.filter(chunk => chunk.length > 10);
  }
  
  private estimateTokens(text: string): number {
    return Math.ceil(text.length / 4);
  }
}
```

### Step 6: Main RAG Service + Channel

**File**: `src/vs/workbench/contrib/void/electron-main/ragMainService.ts` (new)

```typescript
export class RAGMainService extends Disposable {
  private sqlite!: Database;
  private vectorAdapter!: IRAGVectorAdapter;
  private indexService!: RAGIndexService;
  private fileService!: RAGFileService;
  
  constructor(
    @IEnvironmentService private envService: IEnvironmentService,
    @ILogService private logService: ILogService
  ) {
    super();
    this.initialize();
  }
  
  private async initialize(): Promise<void> {
    const pathService = new RAGPathService(this.envService);
    await pathService.ensureDirectories();
    
    // Connect to existing SQLite database
    const dbPath = pathService.getGlobalSqlitePath().fsPath;
    this.sqlite = new Database(dbPath);
    
    // Initialize RAG tables (migration logic)
    this.initializeRAGTables();
    
    // Initialize vector adapter
    const chromaDir = pathService.getGlobalChromaDir().fsPath;
    // Read settings for API key and model
    this.vectorAdapter = new ChromaHttpAdapter(chromaDir, apiKey, model);
    
    // Initialize services
    this.fileService = new RAGFileService();
    this.indexService = new RAGIndexService(this.sqlite, this.vectorAdapter, this.fileService);
  }
  
  private initializeRAGTables(): void {
    // Check if tables exist, create if not (migration-safe)
    const hasRAGTables = this.sqlite.prepare(`
      SELECT name FROM sqlite_master 
      WHERE type='table' AND name='rag_documents'
    `).get();
    
    if (!hasRAGTables) {
      this.sqlite.exec(/* SQL schema from above */);
    }
  }
  
  async indexDocument(uri: URI, isPolicyManual: boolean): Promise<string> {
    return this.indexService.indexDocument(uri, isPolicyManual);
  }
  
  async searchSimilar(query: string, scope: string, limit: number): Promise<SearchResult[]> {
    const collectionName = scope === 'policy' ? 'policy_manual' : 'workspace_docs';
    const vectorResults = await this.vectorAdapter.query(collectionName, query, limit);
    
    // Enrich with SQLite metadata
    const enrichedResults = vectorResults.map(result => {
      const chunkData = this.sqlite.prepare(`
        SELECT c.*, d.filename, d.filetype
        FROM rag_chunks c
        JOIN rag_documents d ON c.docId = d.id
        WHERE c.chunkId = ?
      `).get(result.id);
      
      return {
        ...result,
        source: {
          filename: chunkData.filename,
          filetype: chunkData.filetype,
          chunkIndex: chunkData.chunkIndex,
          isPolicyManual: scope === 'policy'
        }
      };
    });
    
    return enrichedResults;
  }
  
  async getStats(): Promise<RAGStats> {
    // Query database for statistics
  }
}
```

**File**: `src/vs/workbench/contrib/void/electron-main/ragMainChannel.ts` (new)

```typescript
export class RAGMainChannel implements IServerChannel {
  constructor(private ragService: RAGMainService) {}
  
  listen<T>(_: unknown, event: string): Event<T> {
    throw new Error(`Event not found: ${event}`);
  }
  
  call(_: unknown, command: string, arg?: any): Promise<any> {
    switch (command) {
      case 'indexDocument':
        return this.ragService.indexDocument(URI.revive(arg.uri), arg.isPolicyManual);
      case 'searchSimilar':
        return this.ragService.searchSimilar(arg.query, arg.scope, arg.limit);
      case 'getStats':
        return this.ragService.getStats();
      default:
        throw new Error(`Call not found: ${command}`);
    }
  }
}
```

### Step 7: Context Pack Service (Browser)

**File**: `src/vs/workbench/contrib/void/browser/ragContextService.ts` (new)

```typescript
export class RAGContextService {
  constructor(private ragChannel: IChannel) {}
  
  async assembleContextPack(query: string, scope: string, limit: number): Promise<ContextPack> {
    const startTime = Date.now();
    
    const results = await this.ragChannel.call('searchSimilar', { query, scope, limit });
    
    // MMR-style deduplication and ranking
    const deduped = this.deduplicate(results);
    
    // Assemble context
    const answerContext = deduped
      .map(r => r.snippet)
      .join('\n\n')
      .substring(0, 8000); // Cap at 8k chars
    
    const attributions = deduped.map(r => ({
      docId: r.docId,
      chunkId: r.chunkId,
      filename: r.source.filename,
      rangeHint: `chunk ${r.source.chunkIndex}`,
      score: r.score
    }));
    
    return {
      answerContext,
      attributions,
      totalResults: results.length,
      responseTime: Date.now() - startTime
    };
  }
  
  private deduplicate(results: SearchResult[]): SearchResult[] {
    // Remove duplicate chunks from same doc, keep highest scoring
    const seen = new Map<string, SearchResult>();
    
    for (const result of results) {
      const key = `${result.docId}-${result.chunkId}`;
      if (!seen.has(key) || seen.get(key)!.score < result.score) {
        seen.set(key, result);
      }
    }
    
    return Array.from(seen.values()).sort((a, b) => b.score - a.score);
  }
}
```

### Step 8: Tool Integration

**File**: `src/vs/workbench/contrib/void/common/toolsServiceTypes.ts` (modify)

Add to existing tool types:

```typescript
export type BuiltInToolName = 
  | 'fetch_source_code'
  | 'terminal'
  | 'rag_index_document'
  | 'rag_search_policy'
  | 'rag_search_workspace'
  | 'rag_get_stats';
```

**File**: `src/vs/workbench/contrib/void/browser/toolsService.ts` (modify)

Add to existing tools array:

```typescript
{
  name: 'rag_search_policy',
  description: 'Search policy manuals using RAG for relevant information',
  parameters: {
    type: 'object',
    properties: {
      query: { type: 'string', description: 'Search query' },
      limit: { type: 'number', default: 5, description: 'Max results' }
    },
    required: ['query']
  },
  handler: async (params: { query: string; limit?: number }) => {
    const contextService = accessor.get(IRAGContextService);
    const pack = await contextService.assembleContextPack(
      params.query,
      'policy',
      params.limit || 5
    );
    
    return {
      result: pack.answerContext,
      metadata: {
        sources: pack.attributions,
        totalResults: pack.totalResults,
        responseTime: pack.responseTime
      }
    };
  }
}
```

## Implementation - Phase 2: Extension UI

### Step 9: Extension Structure

**File**: `extensions/safe-appeals-nav/package.json`

```json
{
  "name": "safe-appeals-nav",
  "displayName": "Safe Appeals Navigator",
  "description": "Policy manual viewer with RAG search",
  "version": "1.0.0",
  "publisher": "voideditor",
  "engines": { "vscode": "^1.90.0" },
  "categories": ["Other"],
  "main": "./out/extension.js",
  "contributes": {
    "viewsContainers": {
      "activitybar": [{
        "id": "safe-appeals-nav",
        "title": "Policy Manual",
        "icon": "resources/policy-icon.svg"
      }]
    },
    "views": {
      "safe-appeals-nav": [{
        "id": "policyTreeView",
        "name": "Policy Documents"
      }]
    },
    "commands": [
      {
        "command": "safeAppeals.uploadPolicy",
        "title": "Upload Policy Manual",
        "icon": "$(add)"
      },
      {
        "command": "safeAppeals.searchPolicy",
        "title": "Search Policy Manual",
        "icon": "$(search)"
      },
      {
        "command": "safeAppeals.refreshTree",
        "title": "Refresh",
        "icon": "$(refresh)"
      }
    ],
    "customEditors": [{
      "viewType": "safeAppeals.policyViewer",
      "displayName": "Policy Document Viewer",
      "selector": [
        { "filenamePattern": "*.pdf" },
        { "filenamePattern": "*.docx" },
        { "filenamePattern": "*.txt" },
        { "filenamePattern": "*.md" }
      ],
      "priority": "option"
    }]
  }
}
```

### Step 10: Tree View Provider

**File**: `extensions/safe-appeals-nav/src/policyTreeProvider.ts`

```typescript
export class PolicyTreeProvider implements vscode.TreeDataProvider<PolicyItem> {
  private _onDidChangeTreeData = new vscode.EventEmitter<PolicyItem | undefined>();
  readonly onDidChangeTreeData = this._onDidChangeTreeData.event;
  
  refresh(): void {
    this._onDidChangeTreeData.fire(undefined);
  }
  
  async getChildren(element?: PolicyItem): Promise<PolicyItem[]> {
    // Call via command to main process
    const docs = await vscode.commands.executeCommand('_void.rag.getAllDocs');
    return docs.map((d: any) => new PolicyItem(d.filename, d.id, 'document'));
  }
  
  getTreeItem(element: PolicyItem): vscode.TreeItem {
    return element;
  }
}
```

### Step 11: Document Viewer

**File**: `extensions/safe-appeals-nav/src/policyViewerProvider.ts`

Similar to txt-rich-editor but with PDF page navigation and search highlights.

### Step 12: Compilation and Registration

**File**: `build/gulpfile.extensions.js` (modify)

Add to compilations array:

```javascript
'extensions/safe-appeals-nav/tsconfig.json'
```

**File**: `src/vs/workbench/contrib/void/browser/void.contribution.ts` (modify)

Register services:

```typescript
registerSingleton(IRAGContextService, RAGContextService, InstantiationType.Delayed);
```

## Dependencies

Add to root `package.json`:

```json
{
  "dependencies": {
    "chromadb": "^1.8.1",
    "pdfjs-dist": "^4.0.269",
    "mammoth": "^1.6.0"
  }
}
```

Note: `@vscode/sqlite3` already exists in codebase.

## Testing Strategy

1. Unit tests for chunking, extraction
2. Integration tests for index/search flow
3. E2E tests for extension UI

## Acceptance Criteria

Phase 1:

- Index PDF/DOCX/TXT/MD into SQLite + Chroma
- Search returns ContextPack with attributions
- Tools callable from chat

Phase 2:

- Tree view shows indexed documents
- Document viewer displays all formats
- Search highlights in viewer

### To-dos

- [ ] Define RAG types in ragServiceTypes.ts and add settings to voidSettingsTypes.ts
- [ ] Implement RAGPathService for storage directory resolution
- [ ] Create IRAGVectorAdapter interface and ChromaHttpAdapter implementation
- [ ] Implement RAGFileService for PDF/DOCX/TXT/MD extraction
- [ ] Build RAGIndexService with chunking and SQLite storage
- [ ] Create RAGMainService in electron-main with DB initialization
- [ ] Implement RAGMainChannel for IPC communication
- [ ] Build RAGContextService for context pack assembly
- [ ] Add RAG tools to toolsService.ts
- [ ] Add RAG tables to SQLiteStorageDatabase in storage.ts
- [ ] Create safe-appeals-nav extension structure
- [ ] Implement PolicyTreeProvider for sidebar
- [ ] Build PolicyViewerProvider custom editor
- [ ] Register services in void.contribution.ts
- [ ] Add unit and integration tests